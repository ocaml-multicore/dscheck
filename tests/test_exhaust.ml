(* Broken tests generated by exhaust.exe *)

module Atomic = Dscheck.TracedAtomic
module Domain = Dscheck.TracedAtomic

let test_no_spawn () =
  let test () =
    let _ = Atomic.make 0 in
    ()
  in
  (* FIXME: "no enabled processes" exception? *)
  Atomic.trace test

let test_final () =
  let test () =
    let ok = ref false in
    Domain.spawn (fun () -> Domain.spawn (fun () -> ok := true)) ;
    Atomic.final (fun () -> Atomic.check (fun () -> !ok))
  in
  (* FIXME: final is called early? *)
  Atomic.trace test

let test_missing () =
  let values = ref [] in
  let test () =
    let t = Atomic.make 0 in
    Domain.spawn (fun () -> Atomic.set t 1);
    Atomic.set t 2;
    Atomic.final (fun () -> values := Atomic.get t :: !values)
  in
  Atomic.trace test;
  let values = List.sort Int.compare !values in
  (* FIXME: why is 2 missing? *)
  Alcotest.(check (list int)) "multiple outcomes" [ 1; 2 ] values

let test_redundant () =
  let values = ref [] in
  let test () =
    let t = Atomic.make 0 in
    Domain.spawn (fun () -> Atomic.set t 1);
    Domain.spawn (fun () -> Atomic.set t 2);
    Atomic.final (fun () -> values := Atomic.get t :: !values)
  in
  Atomic.trace test;
  let values = List.sort Int.compare !values in
  (* FIXME: why the double 2? *)
  Alcotest.(check (list int)) "multiple outcomes" [ 1; 2 ] values

let () =
  let open Alcotest in
  run "dscheck"
    [
      ( "exhaust",
        [
          test_case "no-spawn" `Quick test_no_spawn;
          test_case "final" `Quick test_final;
          test_case "missing" `Quick test_missing;
          test_case "redundant" `Quick test_redundant;
        ] );
    ]
